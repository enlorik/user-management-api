# ── DATABASE ─────────────────────────────────────────────────────────────────
spring.datasource.url=jdbc:postgresql://${PGHOST}:${PGPORT}/${PGDATABASE}?sslmode=require
spring.datasource.username=${PGUSER}
spring.datasource.password=${PGPASSWORD}

# ── HIKARICP CONNECTION POOL (Production Optimized for Railway) ─────────────
# Test connections before use to prevent using closed connections
spring.datasource.hikari.connection-test-query=SELECT 1
# Maximum pool size - Railway has limited connections
spring.datasource.hikari.maximum-pool-size=${HIKARI_MAX_POOL_SIZE:5}
# Minimum idle connections
spring.datasource.hikari.minimum-idle=${HIKARI_MIN_IDLE:2}
# Connection timeout (20 seconds)
spring.datasource.hikari.connection-timeout=${HIKARI_CONNECTION_TIMEOUT:20000}
# Maximum lifetime of a connection (10 minutes to prevent stale connections)
spring.datasource.hikari.max-lifetime=${HIKARI_MAX_LIFETIME:600000}
# Idle timeout (5 minutes)
spring.datasource.hikari.idle-timeout=${HIKARI_IDLE_TIMEOUT:300000}
# Validation timeout
spring.datasource.hikari.validation-timeout=${HIKARI_VALIDATION_TIMEOUT:5000}
# Leak detection threshold (helps identify connection leaks)
spring.datasource.hikari.leak-detection-threshold=${HIKARI_LEAK_DETECTION_THRESHOLD:60000}

# ── FLYWAY DATABASE MIGRATIONS ──────────────────────────────────────────────
# Enable Flyway migrations
spring.flyway.enabled=true
# Location of migration scripts
spring.flyway.locations=classpath:db/migration
# Create schema history table if it doesn't exist
spring.flyway.baseline-on-migrate=true
# Validate migrations on startup
spring.flyway.validate-on-migrate=true

# ── JPA / Hibernate ─────────────────────────────────────────────────────────
spring.jpa.hibernate.ddl-auto=validate
spring.jpa.show-sql=false
spring.jpa.properties.hibernate.format_sql=true

# ── EMAIL (Resend API - Production) ────────────────────────────────────────
# Production email is handled via Resend API (see EmailService.java)
# These environment variables must be set in Railway:
# - RESEND_API_KEY: Your Resend API key
# - RESEND_FROM: Sender email address (e.g., "User Management <onboarding@resend.dev>")
resend.api.key=${RESEND_API_KEY}
resend.from=${RESEND_FROM}

# Email retry configuration
# Maximum number of retry attempts for transient email failures (5xx errors, timeouts, etc.)
email.retry.max-attempts=${EMAIL_RETRY_MAX_ATTEMPTS:3}
# Initial delay between retry attempts in milliseconds (uses exponential backoff)
email.retry.delay-ms=${EMAIL_RETRY_DELAY_MS:1000}

# ── MAIL (SMTP - Legacy/Optional) ───────────────────────────────────────────
# Spring Mail SMTP configuration (optional, not used in production)
# If you need SMTP fallback, set these environment variables:
spring.mail.host=${SPRING_MAIL_HOST:smtp.example.com}
spring.mail.port=${SPRING_MAIL_PORT:587}
spring.mail.username=${SPRING_MAIL_USERNAME:user@example.com}
spring.mail.password=${SPRING_MAIL_PASSWORD:password}
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true
spring.mail.from=${SPRING_MAIL_FROM:user@example.com}

# ── LOGGING ─────────────────────────────────────────────────────────────────
logging.level.org.springframework.mail=DEBUG
logging.level.com.empress.usermanagementapi.service.EmailService=INFO

# ── ACTUATOR (Health Check) ─────────────────────────────────────────────────
management.endpoints.web.exposure.include=health
management.endpoint.health.show-details=when-authorized
management.health.defaults.enabled=true
# Disable mail health check to prevent false negatives when mail server is unreachable
# The application can still function without mail for most operations
management.health.mail.enabled=false

# ── APPLICATION BASE URL ────────────────────────────────────────────────────
# Base URL for the application, used for generating links in emails and API documentation
# Set this environment variable to match your deployment environment
app.base-url=${APP_BASE_URL:https://user-management-api-java.up.railway.app}

# ── JWT AUTHENTICATION ──────────────────────────────────────────────────────
# JWT secret key for signing tokens (must be at least 256 bits / 32 bytes)
# SECURITY: Generate a strong random secret using: openssl rand -base64 64
# IMPORTANT: Set JWT_SECRET environment variable in production - never use the default!
jwt.secret=${JWT_SECRET:dGhpcy1pcy1hLWRlZmF1bHQtc2VjcmV0LWtleS1mb3ItZGV2ZWxvcG1lbnQtb25seS1jaGFuZ2UtaW4tcHJvZHVjdGlvbg==}
# JWT token expiration time in milliseconds (default: 24 hours)
jwt.expiration=${JWT_EXPIRATION:86400000}

# ── OPENAI API ──────────────────────────────────────────────────────────────
# OpenAI API key for AI-powered log summarization
# Get your API key from: https://platform.openai.com/api-keys
# IMPORTANT: Set OPENAI_API_KEY environment variable to enable AI features
# - For local development: export OPENAI_API_KEY="sk-proj-your-key-here"
# - For Railway production: Set in Railway dashboard Variables tab
# If not configured, the system will fall back to rule-based log summarization
openai.api.key=${OPENAI_API_KEY:}

# IDK BUT IT WORKS
